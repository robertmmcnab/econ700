---
title: "Data frames in R"
format:
  html:
    toc: true
    toc-depth: 3
    toc-location: right
    self-contained: false     # must be false when using webr
urlcolor: blue
filters:
  - webr
execute:
  webR: true
---

```{r setup, echo = FALSE, message = FALSE}

library(dplyr, quietly = TRUE)
library(ggplot2, quietly = TRUE)
library(kableExtra, quietly = TRUE)
library(tidyquant, quietly = TRUE)

```

## Creating a Data Frame

So far, everything we have created has been stored as a variable or vector. A **matrix** consists of rows and columns. The organization of the matrix is important. In some cases, the rows will correspond to individual observations with variables in the columns. In other cases, the variables are in the rows and individuals in columns. Matrices can contain quantitative and qualitative elements.

A matrix is a table or a two-dimensional array-like structure. In R, a **data frame** is a list of variables with the same number of rows with unique row names. If we use the dplyr package, a **tibble** is similar to a data frame.

A data frame can have one column with numeric elements, another with date elements, another with character elements, and so on. 

In the webR code chunk below, we create two vectors, **x8** and **x9**. 

We can **bind** these vectors together, that is, 'merge' the two vectors. How we choose to put the vectors together is important.

There are two functions at our disposal: **rbind** and **cbind**.

The **rbind** function "stacks" the observations in the vectors. 

The **cbind** function "adds" the column of the second vector to the first vector, creating a data frame with two columns.

### Using rbind

In the chunk below, we use the rbind function to bind the two vectors together.

First, we bind **x9** to **x8**. We then bind **x8** to **x9**.

Note that we bind within the **kable** function. We do not create a new matrix.

```{webr-r}

rm(list = ls())

#kableExtra and dplyr are loaded

#Create X8 as equal to the sequence of numbers from 3 to 6
#Create X9 as equal to the sequence of numbers from 10 to 13

x8 <- 3:6
x9 <- 10:13

#Row bind x9 to x8 

kable(rbind(x8,x9))

#Row bind x8 to x9

kable(rbind(x9,x8))

```

### Using cbind

In the following chunk, we demonstrate the **cbind** function, that is, column bind.

First, we bind **x9** to **x8**. We then bind **x8** to **x9**.

Note that we bind within the **kable** function. We do not create a new matrix.


```{webr-r}

rm(list = ls())

#kableExtra and dplyr are loaded

#Create X8 as equal to the sequence of numbers from 3 to 6
#Create X9 as equal to the sequence of numbers from 10 to 13

x8 <- 3:6
x9 <- 10:13


#Column bind x9 to x8

kable(cbind(x8, x9))

# Column bind x8 to x9

kable(cbind(x9,x8))

```

## Creating a data frame

Previously, we created a matrix by binding two vectors together. We can now create a **data frame** or **tibble**. 

A tibble is a more modern version of the standard R data farme. It is part of the *tidyverse* collection of packages.

If you want to learn more about tibbles, see <https://tibble.tidyverse.org/>

In the code chunk below, we again create our two variables. This time, however, we store the two variables in a data frame (original R) and a tibble (new and improved).


```{webr-r}

rm(list = ls())

#kableExtra and dplyr are loaded

#Create X8 as equal to the sequence of numbers from 3 to 6
#Create X9 as equal to the sequence of numbers from 10 to 13

x8 <- 3:6
x9 <- 10:13

df_1 <- data.frame(x8,x9)

tib_1 <- tibble(x8, x9)

kable(df_1,
      align = 'c',
      caption = 'Data Frame') 

kable(tib_1,
      align = 'c',
      caption = 'Tibble')

```

## Using an Existing Dataframe

R comes with a number of "built in" data sets. For the following discussion, we use the *mtcars* data. The data contain observations on a number of cars from the Motor Trend magazine.

One can work directly with the *mtcars* data or assign the *mtcars* data to a data frame. In the following, we assign *mtcars* to the *cardata* data frame. We use the assignment operator so that data flows from *mtcars* to *cardata*.

We can now use the **head** or **tail** functions to examine the structure of the *cardata* data frame. Note that the **head** function returns the first six rows while the **tail** function returns the last six rows.

```{webr-r}

rm(list = ls())

cardata <- mtcars

head(cardata)

tail(cardata)

```


## Dimensions of a Data Frame

To find the dimensions of a data frame, we can determine the number of rows and the number of columns separately or together. First, the **nrow** and **ncol** functions determine the number of rows and columns in a data frame, respectively.

We can also use the **dim** function to return the dimensions of the data frame. Note that the **dim** function returns rows then columns.

```{webr-r}

rm(list = ls())

cardata <- mtcars

# Number of rows

nrow(cardata)

# Number of columns

ncol(cardata)

# Dimensions of data frame (rows and columns)

dim(cardata)
```

## Selecting Rows or Columns in a Data Frame

Having determined the dimensions of the *cardata* data frame, we can now select parts of the data frame.

We can approach this by recognizing that a data frame is organized by rows and columns. 

For example, *mtcars[1,1]* returns the value stored in the intersection of the first row and first column in the data frame. The first row in the data frame is for the Mazda RX4 and the first column in the data frame is for miles per gallon, so the intersection of these two produces a value of 21.0. In other words, the Maxda RX4 earns 21.0 miles per gallon.

So, in general, for a data frame or tibble, *data[row,column]*. 

For example, *cardata[1:2, 2:3]* returns rows 1 to 2 and columns 2 to 3.

```{webr-r}

rm(list = ls())

# First observation, First variable.

cardata[1,1]

# First two observations, 2nd and 3rd variables

cardata[1:2, 2:3]

```

If the row or column is left blank, all values for the column are the result. 

For example, *cardata[,1]* would return all rows for the first column of data. On the other hand, *cardata[1:2,]* would return the first two rows and all the columns.

```{webr-r}

rm(list = ls())

# All rows, first two columns

cardata[,1:2]

# First two observations, All Columns

cardata[1:2,]

```

## Manipulating the Dataframe and Adding New Variables

Starting with the **cardata** data frame, we can now utilize one of the features of the packages to **pipe** the data. 

Piping means that the data 'flows' in the direction of the pipe. It's actually called a pipeline of data.

A bit of housekeeping. We want to convert the rownames in **cardata** to a variable. 

We pipe the data frame and then use the function **rownames\_to\_column()** to do just that. We then pipe the data to rename the new variable **rowname** to **car**.

We can now use the **mutate** function to create a new variable or replace an existing variable.

In the following code, the data flow from cardata to the next line of code to create a new variable **km\_per\_gallon** using the mutate function.

Imagine a temporary data frame that consists of **cardata** with a new column for the **km\_per\_gallon** variable.

Each new line of within the mutate} function creates a new variable. The second variable that we create converts kilometers per gallon to kilometers per liter or **km\_per\_liter**.

Your temporary data frame now consists of the cardata data frame plus the two new variables.

The third line of the mutate statement creates a new variable that converts miles per gallon into kilometers per liter, essentially duplicating the process of the first two lines of the mutate statement. The new variable is called **km2\_per\_liter**.

At this point, you decide you only need to keep a subset of variables. 

We pipe the resulting data frame to the **select** statement. The variables included in the select statement are kept in the temporary data frame while the variables excluded from the select statement are deleted from the temporary data frame.

You have now reached the end of the pipe. The "\<-" at the beginning then assigns all the data in the temporary data frame to the **cardata2** data frame. Because we have used the grammar of piping, the original data frame is unchanged.

The grammar of piping is very useful as it allows you to manipulate a data frame without changing the contents of the original data frame.

Note how we can start using some of the additional features in the **kableExtra** package to rename column names for improve presentation.

```{r, message = FALSE, warning = FALSE, results = 'hold'}

rm(list = ls())

library(dplyr)
library(kableExtra)
library(tidyverse)

cardata <- mtcars 

cardata2 <- cardata %>%
  rownames_to_column() %>%
  rename(car           = rowname) %>%
  mutate(km_per_gallon = mpg*1.60934,
         km_per_liter  = km_per_gallon*3.78541,
         km2_per_liter = mpg*1.60934*3.78541) %>%
  select(car, mpg, cyl, wt, km_per_gallon, km_per_liter, km2_per_liter)

kable(cardata[1:5,])

kable(cardata2[1:5,],
      col.names = c("Car",
                    "MPG",
                    "Cylinders",
                    "Weight",
                    "Kilometers per Gallon",
                    "Kliometers per Liter",
                    "Squared KM/Gallon")) %>%
kable_classic()

```

## The FRED API for Real GDP

An Application Programming Interface (API) allows us to obtain data from a source without having to manually downloading the data. In effect, an API allows us to "grab" data from an external source. If the external source updates the data, then our next API call with obtain the updated data.

For example, let's say we wanted to obtain data from FRED on real Gross Domestic Product (GDP) for the United States from 1980 to the most current data available. We could go to FRED, search for real GDP, find the real GDP variable is called **GDPC1**, and download the data into an Excel file. This process is labor-intensive and subject to error.

FRED: <https://fred.stlouisfed.org/>

Real GDP: <https://fred.stlouisfed.org/series/GDPC1>

We can use an API call to obtain the data. Instead of having to write the code for an API call, we can use a package called **tidyquant**.

We have the variable name **GDPC1** and so we can simply use the **tq\_get** function in tidyquant to retrieve the real GDP series. 

We rename the **price** variable to **rgdp** and we convert the date using the lubridate package.

We can use the *head* or *kable* to print out the contents of the first rows of the resulting data frame.

We see the data are organized such that each row corresponds to a time period, that is, the first row represents real GDP for the 1st quarter of 1950, the second row represents real GDP for the 2nd quarter of 1950, and so on.

```{r, fig.height = 4, fig.width = 6, fig.align = "center"}


rm(list = ls())

#Load packages

library(dplyr)
library(lubridate)
library(tidyverse)
library(kableExtra)
library(tidyquant)

#Use tq_get to obtain real GDP from FRED

rgdp <- tq_get("GDPC1",
                    get  = "economic.data",
                    from = "1950-01-01" ) %>%
        rename(rgdp = price) %>%
        mutate(date = lubridate::ymd(date))

kable(rgdp[1:5,]) %>%
  kable_classic()

```

## The FRED API for Nominal GDP

We can also make an API call to FRED for the nominal GDP series. Much like the real GDP API call, we have a data frame with the **price** variable containing the values for nominal GDP. We rename the variable to **gdp** and also use the lubridate package for the dates.

Nominal GDP: <https://fred.stlouisfed.org/series/GDP>

```{r, messages = FALSE}

rm(list = ls())

#Load packages

library(dplyr)
library(lubridate)
library(tidyverse)
library(kableExtra)
library(tidyquant)

#Use tq_get to obtain nominal GDP from FRED

gdp <- tq_get("GDP",
                    get  = "economic.data",
                    from = "1950-01-01" ) %>%
        rename(gdp = price) %>%
        mutate(date = lubridate::ymd(date))

kable(gdp[1:5,]) %>%
  kable_classic()
```

## The FRED API for Nominal and Real GDP

In the previous examples, we made an API call for one variable at a time. The result was two data frames, one for nominal GDP, and one for real GDP. It would be more efficient to make one API call that results in a single data frame with both variables.

In the following code, we **combine** the names of the two variables, that is, *c("GDP","GDPC1")* creates a row vector with the two names. This row vector is used by the **tq\_get** function to make an API call to obtain the two variables from FRED.

What's important to note is that the *all\_gdp* data fame is in **long** format. In other words, each row corresponds to one period of time for one variable.

We have to do some housecleaning. When we obtain the data from FRED, the variable names are contained in a variable called **symbol** and the values are contained in a variable named **price**. We rename those to **variable** and **value**, respectively.

We then plot the data using the **ggplot2** package. 

The ggplot function is very flexible and you can modify almost every element of a graph. For now, we provide the example and will work on developing our graphing skills later on in the course.

```{r gdp1, echo = TRUE, message = FALSE, results = 'asis', fig.height = 5, fig.width = 6, fig.align = "center"}


rm(list = ls())

#Load packages

library(dplyr)
library(kableExtra)
library(lubridate)
library(tidyquant)
library(tidyverse)
library(ggplot2)

#Use tq_get to obtain nominal and real GDP from FRED

all_gdp <- tq_get(c("GDP", "GDPC1"), 
                  get  = "economic.data",
                    from = "1950-01-01") %>%
        mutate(date     = lubridate::ymd(date)) %>%
        rename(variable = symbol,
               value    = price)

# Produce Table of First 10 Observations

kable(all_gdp[1:10,],
      col.names = c("Variable",
                    "Date",
                    "Value"))

#Use GGPLOT 
#GDP over time

ggplot(data = all_gdp, 
       aes(x = date, 
           y = value,
           color = variable,
           group = variable)) +
geom_line(linewidth = 1) +
scale_y_continuous(labels = scales::dollar_format()) +
theme_minimal() +
theme(legend.position = 'bottom',
      legend.title    = element_blank()) +
labs(title    = "Real and Nominal GDP, United States",
     subtitle = "Billions of Dollars",
     x        = "Date",
     y        = "Billions of Dollars")

```

